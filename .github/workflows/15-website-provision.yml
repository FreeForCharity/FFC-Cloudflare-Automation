name: '15. Website - Provision (Issue Assigned) [CF+Repo]'

on:
  issues:
    types: [assigned]
  workflow_dispatch:
    inputs:
      issue_number:
        description: 'Issue number to process (must be a website request issue)'
        required: true
        type: number

permissions:
  contents: read
  issues: write
  actions: read

env:
  WEBSITE_TARGET_ORG: ${{ vars.FFC_WEBSITE_TARGET_ORG || 'FreeForCharity' }}
  WEBSITE_TEMPLATE_REPO:
    ${{ vars.FFC_WEBSITE_TEMPLATE_REPO || 'FreeForCharity/FFC_Single_Page_Template' }}

jobs:
  resolve:
    runs-on: ubuntu-latest
    outputs:
      skip: ${{ steps.parse.outputs.skip }}
      issue_number: ${{ steps.parse.outputs.issue_number }}
      dns_controlled: ${{ steps.parse.outputs.dns_controlled }}
      website_situation: ${{ steps.parse.outputs.website_situation }}
      current_website_url: ${{ steps.parse.outputs.current_website_url }}
      requester_github_username: ${{ steps.parse.outputs.requester_github_username }}
      technical_poc_github_username: ${{ steps.parse.outputs.technical_poc_github_username }}
      domain: ${{ steps.parse.outputs.domain }}
      charity_name: ${{ steps.parse.outputs.charity_name }}
      footer_email: ${{ steps.parse.outputs.footer_email }}
      footer_phone: ${{ steps.parse.outputs.footer_phone }}
      footer_address_json: ${{ steps.parse.outputs.footer_address_json }}
      footer_ein: ${{ steps.parse.outputs.footer_ein }}
      footer_social_json: ${{ steps.parse.outputs.footer_social_json }}
      leadership_json: ${{ steps.parse.outputs.leadership_json }}
      repo_name: ${{ steps.parse.outputs.repo_name }}
      repo_full: ${{ steps.parse.outputs.repo_full }}
      template_repo: ${{ steps.parse.outputs.template_repo }}
      run_url: ${{ steps.parse.outputs.run_url }}
    steps:
      - name: Parse Website Request
        id: parse
        uses: actions/github-script@v8
        with:
          script: |
            // Handle both issue assignment trigger and manual workflow_dispatch trigger
            let issue;
            if (context.eventName === 'workflow_dispatch') {
              // Manual trigger: fetch the issue by number from inputs
              const issueNumber = context.payload.inputs.issue_number;
              if (!issueNumber) {
                core.setFailed('Invalid issue number provided for manual run');
                return;
              }
              const issueResponse = await github.rest.issues.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
              });
              issue = issueResponse.data;
            } else {
              // Automatic trigger from issue assignment
              issue = context.payload.issue;
            }

            const body = issue.body || '';
            const title = issue.title || '';
            const requesterGitHubUsername = String(issue.user?.login || '').trim();
            const labels = (issue.labels || [])
              .map(l => (typeof l === 'string' ? l : l.name))
              .filter(Boolean);

            // Gate: only act on website requests.
            const isWebsiteRequest = title.startsWith('[WEBSITE REQUEST]') || labels.includes('website-request');
            if (!isWebsiteRequest) {
              core.notice('Not a website request issue; skipping.');
              core.setOutput('skip', 'true');
              return;
            }

            // Idempotency: skip if already completed.
            const marker = '<!-- website-provision:completed -->';
            const comments = await github.paginate(github.rest.issues.listComments, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              per_page: 100,
            });
            if (comments.some(c => (c.body || '').includes(marker))) {
              core.notice('Provisioning already completed for this issue; skipping.');
              core.setOutput('skip', 'true');
              return;
            }

            function escapeRegExp(str) {
              return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }

            function extractSection(heading) {
              const re = new RegExp(`###\\s+${escapeRegExp(heading)}\\s+([\\s\\S]*?)(?=\\n###\\s+|$)`, 'i');
              const m = body.match(re);
              if (!m) return '';
              return String(m[1] || '').trim();
            }

            function normalizeInput(value) {
              const v = String(value || '').trim();
              if (!v) return '';
              if (/^(n\/a|na|none|not applicable|n\.a\.)$/i.test(v)) return '';
              return v;
            }

            function normalizeDomain(value) {
              let v = normalizeInput(value);
              if (!v) return '';
              v = v.replace(/^https?:\/\//i, '');
              v = v.replace(/\/$/, '');
              v = v.replace(/^www\./i, '');
              return v;
            }

            function buildAddress(parts) {
              const line1 = normalizeInput(parts.line1);
              const line2 = normalizeInput(parts.line2);
              const city = normalizeInput(parts.city);
              const state = normalizeInput(parts.state);
              const postal = normalizeInput(parts.postal);
              const country = normalizeInput(parts.country);

              if (!line1 && !line2 && !city && !state && !postal && !country) return '';

              const lines = [];
              if (line1) lines.push(line1);
              if (line2) lines.push(line2);

              const cityStatePostal = [city, state, postal].filter(Boolean).join(', ').replace(/,\s*,/g, ', ');
              if (cityStatePostal) lines.push(cityStatePostal);
              if (country) lines.push(country);

              return lines.join('\\n');
            }

            function buildUrlLine(key, url) {
              const u = normalizeInput(url);
              if (!u) return null;
              if (!/^https?:\/\//i.test(u)) return null;
              return `${key}: ${u}`;
            }

            // Primary (current) issue form fields
            // DNS + domain registration/transfer are handled in a separate ticket.
            // Keep dnsControlled for backward compatibility with older website request issues.
            let dnsControlled = false;

            const websiteSituation = normalizeInput(extractSection('Website Situation'));
            const currentWebsiteUrl = normalizeInput(extractSection('Current Website URL (if any)'));
            let technicalPocGitHubUsername = normalizeInput(extractSection('Technical POC GitHub Username'));
            technicalPocGitHubUsername = technicalPocGitHubUsername.replace(/^@/, '');

            let domain = normalizeDomain(extractSection('Website Domain (no http://)'));
            let charityName = normalizeInput(extractSection('Organization Name (as displayed)'));
            let footerEmail = normalizeInput(extractSection('Footer Contact Email'));
            let footerPhone = normalizeInput(extractSection('Footer Contact Phone'));

            const usingPrimaryForm = !!domain;

            let footerAddress = buildAddress({
              line1: extractSection('Footer Mailing Address Line 1'),
              line2: extractSection('Footer Mailing Address Line 2'),
              city: extractSection('Footer Mailing City'),
              state: extractSection('Footer Mailing State/Province'),
              postal: extractSection('Footer Mailing Postal Code'),
              country: extractSection('Footer Mailing Country'),
            });

            let footerEin = normalizeInput(extractSection('EIN / Tax ID'));

            let footerSocialLinks = [];
            for (const entry of [
              buildUrlLine('facebook', extractSection('Facebook URL')),
              buildUrlLine('x', extractSection('X / Twitter URL')),
              buildUrlLine('linkedin', extractSection('LinkedIn URL')),
              buildUrlLine('github', extractSection('GitHub URL')),
            ]) {
              if (entry) footerSocialLinks.push(entry);
            }

            let leadershipLines = [];
            for (let i = 1; i <= 6; i++) {
              const name = normalizeInput(extractSection(`Leader ${i} Name`));
              const title = normalizeInput(extractSection(`Leader ${i} Role/Title`));
              const linkedin = normalizeInput(extractSection(`Leader ${i} LinkedIn URL`));

              if (!name) continue;
              if (!title) leadershipLines.push(`${name} | Board Member | ${linkedin}`);
              else leadershipLines.push(`${name} | ${title} | ${linkedin}`);
            }

            // Backward-compat: previous website request form fields
            // If the new headings are not present, fall back to the older headings.
            if (!domain) {
              dnsControlled = true;
              domain = normalizeDomain(extractSection('Apex Domain'));
              charityName = normalizeInput(extractSection('Charity / Organization Name'));
              footerEmail = normalizeInput(extractSection('Public Contact Email'));
              footerPhone = normalizeInput(extractSection('Public Contact Phone (optional)'));
              footerAddress = normalizeInput(extractSection('Public Mailing Address (optional)'));
              footerEin = normalizeInput(extractSection('EIN / Tax ID (optional)'));

              const footerSocialLegacy = normalizeInput(extractSection('Social Links (optional)'));
              if (footerSocialLegacy) {
                footerSocialLinks = footerSocialLegacy
                  .split(/\r?\n/)
                  .map(s => s.trim())
                  .filter(Boolean);
              }

              const leadershipLegacy = normalizeInput(extractSection('Board / Leadership'));
              if (leadershipLegacy) {
                leadershipLines = leadershipLegacy
                  .split(/\r?\n/)
                  .map(s => s.trim())
                  .filter(Boolean);
              }
            }

            if (!domain || !charityName || !footerEmail) {
              core.setFailed('Missing required fields: Website Domain, Organization Name, and Footer Contact Email are required.');
              return;
            }

            if (usingPrimaryForm && !technicalPocGitHubUsername) {
              core.setFailed('Missing required fields: Technical POC GitHub Username is required.');
              return;
            }

            if (leadershipLines.length < 1) {
              core.setFailed('Missing required fields: at least one leader must be provided (Leader 1 Name must not be N/A).');
              return;
            }

            const repoName = `FFC-EX-${domain}`;
            const org = process.env.WEBSITE_TARGET_ORG || 'FreeForCharity';
            const repoFull = `${org}/${repoName}`;

            const templateRepo = process.env.WEBSITE_TEMPLATE_REPO || 'FreeForCharity/FFC_Single_Page_Template';
            const runUrl = `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;

            core.setOutput('skip', 'false');
            core.setOutput('issue_number', String(issue.number));
            core.setOutput('dns_controlled', dnsControlled ? 'true' : 'false');
            core.setOutput('website_situation', websiteSituation);
            core.setOutput('current_website_url', currentWebsiteUrl);
            core.setOutput('requester_github_username', requesterGitHubUsername);
            core.setOutput('technical_poc_github_username', technicalPocGitHubUsername);
            core.setOutput('domain', domain);
            core.setOutput('charity_name', charityName);
            core.setOutput('footer_email', footerEmail);
            core.setOutput('footer_phone', footerPhone);
            core.setOutput('footer_address_json', JSON.stringify(footerAddress));
            core.setOutput('footer_ein', footerEin);
            core.setOutput('footer_social_json', JSON.stringify(footerSocialLinks));
            core.setOutput('leadership_json', JSON.stringify(leadershipLines));
            core.setOutput('repo_name', repoName);
            core.setOutput('repo_full', repoFull);
            core.setOutput('template_repo', templateRepo);
            core.setOutput('run_url', runUrl);

  zone_check:
    runs-on: windows-latest
    environment: cloudflare-prod
    needs: [resolve]
    if: needs.resolve.outputs.skip != 'true'
    outputs:
      zone_controlled: ${{ steps.check.outputs.zone_controlled }}
      zone_account: ${{ steps.check.outputs.zone_account }}
      zone_exists_ffc: ${{ steps.check.outputs.zone_exists_ffc }}
      zone_exists_cm: ${{ steps.check.outputs.zone_exists_cm }}
    steps:
      - uses: actions/checkout@v4

      - name: Validate required Cloudflare secrets
        shell: bash
        run: |
          if [ -z "${{ secrets.FFC_CLOUDFLARE_API_TOKEN_ZONE_AND_DNS }}" ]; then
            echo "::error::FFC_CLOUDFLARE_API_TOKEN_ZONE_AND_DNS secret is not set (environment: cloudflare-prod)";
            exit 1;
          fi
          if [ -z "${{ secrets.CM_CLOUDFLARE_API_TOKEN_ZONE_AND_DNS }}" ]; then
            echo "::error::CM_CLOUDFLARE_API_TOKEN_ZONE_AND_DNS secret is not set (environment: cloudflare-prod)";
            exit 1;
          fi

      - name: Cloudflare source-of-truth zone check
        id: check
        shell: pwsh
        env:
          CLOUDFLARE_API_TOKEN_FFC: ${{ secrets.FFC_CLOUDFLARE_API_TOKEN_ZONE_AND_DNS }}
          CLOUDFLARE_API_TOKEN_CM: ${{ secrets.CM_CLOUDFLARE_API_TOKEN_ZONE_AND_DNS }}
        run: |
          $ErrorActionPreference = 'Stop'
          $domain = "${{ needs.resolve.outputs.domain }}"

          $ffc = (& pwsh -NoProfile -File .\scripts\cloudflare-zone-get.ps1 -Domain $domain -Account FFC) | ConvertFrom-Json
          $cm  = (& pwsh -NoProfile -File .\scripts\cloudflare-zone-get.ps1 -Domain $domain -Account CM)  | ConvertFrom-Json

          $existsFfc = [bool]$ffc.exists
          $existsCm  = [bool]$cm.exists
          $controlled = ($existsFfc -or $existsCm)

          $account = ''
          if ($existsFfc) { $account = 'FFC' }
          elseif ($existsCm) { $account = 'CM' }

          $toFlag = {
            param([string]$Name, [bool]$Value)
            $v = if ($Value) { 'true' } else { 'false' }
            "$Name=$v" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          }

          & $toFlag -Name 'zone_exists_ffc' -Value $existsFfc
          & $toFlag -Name 'zone_exists_cm' -Value $existsCm
          & $toFlag -Name 'zone_controlled' -Value $controlled

          "zone_account=$account" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

  announce:
    runs-on: ubuntu-latest
    needs: [resolve, zone_check]
    if: needs.resolve.outputs.skip != 'true'
    steps:
      - name: Comment start
        uses: actions/github-script@v8
        with:
          script: |
            const issueNumber = Number('${{ needs.resolve.outputs.issue_number }}');
            const domain = '${{ needs.resolve.outputs.domain }}';
            const repoFull = '${{ needs.resolve.outputs.repo_full }}';
            const templateRepo = '${{ needs.resolve.outputs.template_repo }}';
            const runUrl = '${{ needs.resolve.outputs.run_url }}';
            const zoneControlled = '${{ needs.zone_check.outputs.zone_controlled }}' === 'true';
            const zoneAccount = '${{ needs.zone_check.outputs.zone_account }}';
            const websiteSituation = '${{ needs.resolve.outputs.website_situation }}';
            const requester = '${{ needs.resolve.outputs.requester_github_username }}';
            const technicalPoc = '${{ needs.resolve.outputs.technical_poc_github_username }}';

            const steps = zoneControlled
              ? [
                  '1) Configure DNS for GitHub Pages (Cloudflare)',
                  '2) Create repo from template + enable Pages + set custom domain',
                  '3) Apply footer + leadership content',
                ]
              : [
                  '1) Create repo from template + enable Pages (no custom domain)',
                  '2) Apply footer + leadership content',
                ];

            const body = [
              `Provisioning started for **${domain}**`,
              '',
              `- Target repo: **${repoFull}**`,
              `- Template: **${templateRepo}**`,
              `- Run: ${runUrl}`,
              websiteSituation ? `- Website situation: **${websiteSituation}**` : null,
              requester ? `- Requester: @${requester}` : null,
              technicalPoc ? `- Technical POC: @${technicalPoc}` : null,
              `- Cloudflare source-of-truth: **${zoneControlled ? 'Controlled (will set custom domain)' : 'Not controlled (no custom domain)'}**${zoneAccount ? ` (account: ${zoneAccount})` : ''}`,
              '',
              'Steps:',
              ...steps,
            ].filter(Boolean).join('\n');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body,
            });

  dns:
    runs-on: windows-latest
    environment: cloudflare-prod
    needs: [resolve, zone_check, announce]
    if: needs.resolve.outputs.skip != 'true' && needs.zone_check.outputs.zone_controlled == 'true'
    steps:
      - uses: actions/checkout@v4

      - name: Validate required Cloudflare secrets
        shell: bash
        run: |
          if [ -z "${{ secrets.FFC_CLOUDFLARE_API_TOKEN_ZONE_AND_DNS }}" ]; then
            echo "::error::FFC_CLOUDFLARE_API_TOKEN_ZONE_AND_DNS secret is not set (environment: cloudflare-prod)";
            exit 1;
          fi
          if [ -z "${{ secrets.CM_CLOUDFLARE_API_TOKEN_ZONE_AND_DNS }}" ]; then
            echo "::error::CM_CLOUDFLARE_API_TOKEN_ZONE_AND_DNS secret is not set (environment: cloudflare-prod)";
            exit 1;
          fi

      - name: Enforce GitHub Pages DNS (apex + www)
        id: enforce
        shell: pwsh
        env:
          CLOUDFLARE_API_TOKEN_FFC: ${{ secrets.FFC_CLOUDFLARE_API_TOKEN_ZONE_AND_DNS }}
          CLOUDFLARE_API_TOKEN_CM: ${{ secrets.CM_CLOUDFLARE_API_TOKEN_ZONE_AND_DNS }}
        run: |
          $ErrorActionPreference = 'Stop'
          $domain = "${{ needs.resolve.outputs.domain }}"

          $outDir = Join-Path $env:RUNNER_TEMP 'website-provision-dns'
          New-Item -ItemType Directory -Force -Path $outDir | Out-Null

          $out = & pwsh -NoProfile -File .\Update-CloudflareDns.ps1 -Zone $domain -EnforceStandard -GitHubPagesOnly *>&1
          $outPath = Join-Path $outDir 'dns-enforce.txt'
          $out | Out-File -FilePath $outPath -Encoding utf8

          $audit = & pwsh -NoProfile -File .\Update-CloudflareDns.ps1 -Zone $domain -Audit -ErrorAction Continue *>&1
          $auditPath = Join-Path $outDir 'dns-audit-after.txt'
          $audit | Out-File -FilePath $auditPath -Encoding utf8

          "out_dir=$outDir" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Upload DNS outputs
        uses: actions/upload-artifact@v6
        with:
          name: website-provision-dns
          path: ${{ steps.enforce.outputs.out_dir }}/*.txt
          if-no-files-found: error

  repo:
    runs-on: windows-latest
    environment: github-prod
    needs: [resolve, zone_check, dns]
    if: >-
      always() && needs.resolve.outputs.skip != 'true' && (needs.dns.result == 'success' ||
      needs.dns.result == 'skipped')
    steps:
      - uses: actions/checkout@v4

      - name: Validate required GitHub token
        shell: pwsh
        run: |
          if ([string]::IsNullOrWhiteSpace("${{ secrets.CBM_TOKEN }}")) {
            throw 'CBM_TOKEN secret is not set (environment: github-prod).'
          }

      - name: Create repo from template + enable Pages
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.CBM_TOKEN }}
        run: |
          $ErrorActionPreference = 'Stop'
          $repoFull = "${{ needs.resolve.outputs.repo_full }}"
          $repoName = "${{ needs.resolve.outputs.repo_name }}"
          $domain = "${{ needs.resolve.outputs.domain }}"
          $charityName = "${{ needs.resolve.outputs.charity_name }}"
          $templateRepo = "${{ needs.resolve.outputs.template_repo }}"
          $zoneControlled = "${{ needs.zone_check.outputs.zone_controlled }}" -eq 'true'

          # Best-effort check: if repo already exists, skip creation.
          $exists = $false
          try {
            gh repo view $repoFull --json nameWithOwner 1>$null
            $exists = $true
          } catch {
            $exists = $false
          }

          if ($exists) {
            Write-Host "Repo already exists: $repoFull. Skipping creation." -ForegroundColor Yellow
          } else {
            $createParams = @{
              RepoName      = $repoName
              Organization  = "${{ env.WEBSITE_TARGET_ORG }}"
              Description   = "Website for $charityName ($domain)"
              TemplateRepo  = $templateRepo
              Visibility    = 'public'
              EnableIssues  = $true
              EnablePages   = $true
            }

            if ($zoneControlled) {
              $createParams.CNAME = $domain
            } else {
              $createParams.PagesDomainType = 'github-default'
            }

            ./scripts/Create-GitHubRepo.ps1 @createParams
          }

      - name: Add maintainers (requester + technical POC)
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.CBM_TOKEN }}
        run: |
          $ErrorActionPreference = 'Stop'

          $repoFull = "${{ needs.resolve.outputs.repo_full }}"
          $requester = "${{ needs.resolve.outputs.requester_github_username }}".Trim()
          $technicalPoc = "${{ needs.resolve.outputs.technical_poc_github_username }}".Trim().TrimStart('@')

          $users = @($requester, $technicalPoc)
          $users = $users | Where-Object { -not [string]::IsNullOrWhiteSpace($_) } | Select-Object -Unique

          foreach ($u in $users) {
            Write-Host "Adding maintainer: $u" -ForegroundColor Cyan
            gh api -X PUT "repos/$repoFull/collaborators/$u" -f permission=maintain 1>$null
          }

  content:
    runs-on: windows-latest
    environment: github-prod
    needs: [resolve, zone_check, repo]
    if: needs.resolve.outputs.skip != 'true'
    steps:
      - uses: actions/checkout@v4

      - name: Validate required GitHub token
        shell: pwsh
        run: |
          if ([string]::IsNullOrWhiteSpace("${{ secrets.CBM_TOKEN }}")) {
            throw 'CBM_TOKEN secret is not set (environment: github-prod).'
          }

      - name: Apply footer + leadership content
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.CBM_TOKEN }}
        run: |
          $ErrorActionPreference = 'Stop'

          $repoFull = "${{ needs.resolve.outputs.repo_full }}"
          $domain = "${{ needs.resolve.outputs.domain }}"
          $charityName = "${{ needs.resolve.outputs.charity_name }}"
          $websiteSituation = "${{ needs.resolve.outputs.website_situation }}"
          $currentWebsiteUrl = "${{ needs.resolve.outputs.current_website_url }}"
          $requester = "${{ needs.resolve.outputs.requester_github_username }}"
          $technicalPoc = "${{ needs.resolve.outputs.technical_poc_github_username }}"
          $zoneControlled = "${{ needs.zone_check.outputs.zone_controlled }}" -eq 'true'

          $footerEmail = "${{ needs.resolve.outputs.footer_email }}"
          $footerPhone = "${{ needs.resolve.outputs.footer_phone }}"
          $footerAddress = '${{ needs.resolve.outputs.footer_address_json }}' | ConvertFrom-Json
          $footerEin = "${{ needs.resolve.outputs.footer_ein }}"

          $footerSocial = '${{ needs.resolve.outputs.footer_social_json }}' | ConvertFrom-Json
          $leadership = '${{ needs.resolve.outputs.leadership_json }}' | ConvertFrom-Json

          $workDir = Join-Path $env:RUNNER_TEMP 'website-provision-repo'
          if (Test-Path $workDir) { Remove-Item -Recurse -Force $workDir }
          New-Item -ItemType Directory -Force -Path $workDir | Out-Null

          $cloneDir = Join-Path $workDir 'repo'
          gh repo clone $repoFull $cloneDir
          Set-Location $cloneDir

          git config user.name "github-actions"
          git config user.email "github-actions@users.noreply.github.com"

          $content = [ordered]@{
            domain = $domain
            charityName = $charityName
            websiteSituation = $websiteSituation
            currentWebsiteUrl = $currentWebsiteUrl
            requesterGitHubUsername = $requester
            technicalPocGitHubUsername = $technicalPoc
            cloudflareZoneControlled = $zoneControlled
            footer = [ordered]@{
              email = $footerEmail
              phone = $footerPhone
              address = $footerAddress
              ein = $footerEin
              socialLinks = @($footerSocial)
            }
            leadership = @($leadership)
            generatedUtc = (Get-Date).ToUniversalTime().ToString('o')
          }

          $json = $content | ConvertTo-Json -Depth 8
          $json | Out-File -FilePath 'ffc-content.json' -Encoding utf8

          # Patch the actual React template files in the newly provisioned repo.
          $scriptPath = Join-Path $env:GITHUB_WORKSPACE 'scripts/Apply-WebsiteReactTemplate.ps1'
          if (-not (Test-Path $scriptPath)) {
            throw "Customization script not found: $scriptPath"
          }

          & $scriptPath `
            -RepoPath $cloneDir `
            -Domain $domain `
            -CharityName $charityName `
            -FooterEmail $footerEmail `
            -FooterPhone $footerPhone `
            -FooterAddress $footerAddress `
            -FooterEin $footerEin `
            -FooterSocial @($footerSocial) `
            -LeadershipLines @($leadership)

          git add -A
          git diff --cached --quiet
          if ($LASTEXITCODE -ne 0) {
            git commit -m "chore: apply footer + leadership content" | Out-Null
            git push origin HEAD:main
          } else {
            Write-Host "No content changes detected; skipping commit." -ForegroundColor Yellow
          }

  finalize:
    runs-on: ubuntu-latest
    needs: [resolve, zone_check, dns, repo, content]
    if: >-
      always() && needs.resolve.outputs.skip != 'true' && (needs.dns.result == 'success' ||
      needs.dns.result == 'skipped') && needs.repo.result == 'success' && needs.content.result ==
      'success'
    steps:
      - name: Comment completion
        uses: actions/github-script@v8
        with:
          script: |
            const issueNumber = Number('${{ needs.resolve.outputs.issue_number }}');
            const domain = '${{ needs.resolve.outputs.domain }}';
            const repoFull = '${{ needs.resolve.outputs.repo_full }}';
            const repoUrl = `${context.serverUrl}/${repoFull}`;
            const runUrl = '${{ needs.resolve.outputs.run_url }}';
            const zoneControlled = '${{ needs.zone_check.outputs.zone_controlled }}' === 'true';

            const marker = '<!-- website-provision:completed -->';
            const dnsNote = zoneControlled
              ? '- DNS enforcement used the standard GitHub Pages-only enforcement (apex + www).'
              : '- DNS was NOT changed and GitHub Pages custom domain was NOT set (domain is not in FFC-controlled Cloudflare yet).';
            const dnsManual = zoneControlled
              ? []
              : [
                  '',
                  'Next steps:',
                  '- Create a follow-up ticket to add/transfer the domain into FFC Cloudflare, then point DNS to GitHub Pages and set the Pages custom domain.',
                  '- GitHub custom domain docs (for reference):',
                  '  https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site',
                ];
            const body = [
              marker,
              `Provisioning completed for **${domain}**`,
              '',
              `- Repo: ${repoUrl}`,
              `- Run: ${runUrl}`,
              '',
              'Notes:',
              dnsNote,
              '- Content was applied directly to the React template footer + leadership sections (and recorded in `ffc-content.json`).',
              ...dnsManual,
            ].join('\n');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body,
            });
