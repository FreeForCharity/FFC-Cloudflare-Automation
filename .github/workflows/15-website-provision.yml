name: '15. Website - Provision (Issue Assigned) [CF+Repo]'

on:
  issues:
    types: [assigned]

  workflow_dispatch:
    inputs:
      domain:
        description: 'Apex domain (example: example.org). This is the only required field.'
        required: true
        type: string
      charity_name:
        description:
          'Organization display name (optional; required only to apply the React template footer).'
        required: false
        type: string
      footer_email:
        description:
          'Public footer contact email (optional; required only to apply the React template footer).'
        required: false
        type: string
      footer_phone:
        description: 'Public US phone number (optional). 10 digits, or 11 digits starting with 1.'
        required: false
        type: string
      footer_address:
        description: 'Footer mailing address (optional; you can paste multi-line text).'
        required: false
        type: string
      footer_ein:
        description: 'EIN / Tax ID (optional).'
        required: false
        type: string
      website_situation:
        description: 'Which common scenario matches? (optional)'
        required: false
        type: choice
        options:
          - 'New charity domain name and new charity website'
          - 'New charity domain name but existing charity site (Wix / Squarespace / etc)'
          - 'Existing domain name and existing website (WordPress / formal hosting)'
      current_website_url:
        description: 'Current website URL (optional; must start with https:// if provided).'
        required: false
        type: string
      requester_github_username:
        description: 'GitHub username to add as maintainer (optional; defaults to the actor).'
        required: false
        type: string
      technical_poc_github_username:
        description: 'GitHub username to add as maintainer (optional).'
        required: false
        type: string
      social_links:
        description:
          "Social links (optional). One per line as 'platform: https://...'. Must use https://."
        required: false
        type: string
      leadership_lines:
        description:
          "Leadership lines (optional). One per line as 'Name | Title | LinkedIn URL'. LinkedIn URL
          must be https:// if provided."
        required: false
        type: string

permissions:
  contents: read
  issues: write
  actions: read

env:
  WEBSITE_TARGET_ORG: FreeForCharity
  WEBSITE_TEMPLATE_REPO: FreeForCharity/FFC_Single_Page_Template

jobs:
  resolve:
    runs-on: ubuntu-latest
    outputs:
      skip: ${{ steps.parse.outputs.skip }}
      issue_number: ${{ steps.parse.outputs.issue_number }}
      post_comments: ${{ steps.parse.outputs.post_comments }}
      dns_controlled: ${{ steps.parse.outputs.dns_controlled }}
      website_situation: ${{ steps.parse.outputs.website_situation }}
      current_website_url: ${{ steps.parse.outputs.current_website_url }}
      requester_github_username: ${{ steps.parse.outputs.requester_github_username }}
      technical_poc_github_username: ${{ steps.parse.outputs.technical_poc_github_username }}
      domain: ${{ steps.parse.outputs.domain }}
      charity_name: ${{ steps.parse.outputs.charity_name }}
      footer_email: ${{ steps.parse.outputs.footer_email }}
      footer_phone: ${{ steps.parse.outputs.footer_phone }}
      footer_address_json: ${{ steps.parse.outputs.footer_address_json }}
      footer_ein: ${{ steps.parse.outputs.footer_ein }}
      footer_social_json: ${{ steps.parse.outputs.footer_social_json }}
      leadership_json: ${{ steps.parse.outputs.leadership_json }}
      repo_name: ${{ steps.parse.outputs.repo_name }}
      repo_full: ${{ steps.parse.outputs.repo_full }}
      template_repo: ${{ steps.parse.outputs.template_repo }}
      run_url: ${{ steps.parse.outputs.run_url }}
    steps:
      - name: Parse Website Request
        id: parse
        uses: actions/github-script@v8
        with:
          script: |
            const isManual = context.eventName === 'workflow_dispatch';
            const manualInputs = context.payload.inputs || {};
            const issue = context.payload.issue || {};
            const body = isManual ? '' : (issue.body || '');
            const title = isManual ? '' : (issue.title || '');
            const requesterFromIssue = String(issue?.user?.login || '').trim();
            const labels = (issue.labels || [])
              .map(l => (typeof l === 'string' ? l : l.name))
              .filter(Boolean);

            // Gate: only act on website requests.
            const isWebsiteRequest = isManual || title.startsWith('[WEBSITE REQUEST]') || labels.includes('website-request');
            if (!isWebsiteRequest) {
              core.notice('Not a website request issue; skipping.');
              core.setOutput('skip', 'true');
              core.setOutput('post_comments', 'false');
              return;
            }

            const requesterGitHubUsername = (
              String(manualInputs.requester_github_username || '').trim().replace(/^@/, '') ||
              requesterFromIssue ||
              String(context.actor || '').trim()
            );

            // Idempotency: skip if already completed.
            const marker = '<!-- website-provision:completed -->';
            if (!isManual) {
              const comments = await github.paginate(github.rest.issues.listComments, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                per_page: 100,
              });
              if (comments.some(c => (c.body || '').includes(marker))) {
                core.notice('Provisioning already completed for this issue; skipping.');
                core.setOutput('skip', 'true');
                core.setOutput('post_comments', 'true');
                core.setOutput('issue_number', String(issue.number));
                return;
              }
            }

            function escapeRegExp(str) {
              return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }

            function extractSection(heading) {
              const re = new RegExp(`###\\s+${escapeRegExp(heading)}\\s+([\\s\\S]*?)(?=\\n###\\s+|$)`, 'i');
              const m = body.match(re);
              if (!m) return '';
              return String(m[1] || '').trim();
            }

            function normalizeInput(value) {
              const v = String(value || '').trim();
              if (!v) return '';
              return v;
            }

            function normalizeDomain(value) {
              let v = normalizeInput(value);
              if (!v) return '';
              v = v.replace(/^https?:\/\//i, '');
              v = v.replace(/\/$/, '');
              v = v.replace(/^www\./i, '');
              return v;
            }

            function parseMultiline(value) {
              const v = String(value || '').trim();
              if (!v) return [];
              return v
                .split(/\r?\n/)
                .map(s => String(s || '').trim())
                .filter(Boolean);
            }

            function buildAddress(parts) {
              const line1 = normalizeInput(parts.line1);
              const line2 = normalizeInput(parts.line2);
              const city = normalizeInput(parts.city);
              const state = normalizeInput(parts.state);
              const postal = normalizeInput(parts.postal);
              const country = normalizeInput(parts.country);

              if (!line1 && !line2 && !city && !state && !postal && !country) return '';

              const lines = [];
              if (line1) lines.push(line1);
              if (line2) lines.push(line2);

              const cityStatePostal = [city, state, postal].filter(Boolean).join(', ').replace(/,\s*,/g, ', ');
              if (cityStatePostal) lines.push(cityStatePostal);
              if (country) lines.push(country);

              return lines.join('\\n');
            }

            function buildUrlLine(key, url) {
              const u = normalizeInput(url);
              if (!u) return null;
              if (!/^https:\/\//i.test(u)) return null;
              return `${key}: ${u}`;
            }

            function validateOptionalUrl(label, url) {
              const u = normalizeInput(url);
              if (!u) return '';
              if (isNA(u)) {
                core.setFailed(`Invalid value: ${label} cannot be N/A.`);
                return null;
              }
              if (!/^https:\/\//i.test(u)) {
                core.setFailed(`Invalid value: ${label} must start with https://.`);
                return null;
              }
              return u;
            }

            function validateRequiredUrl(label, url) {
              const u = normalizeInput(url);
              if (isDisallowedValue(u)) {
                core.setFailed(`Invalid value for required field: ${label}. Please provide a real URL (not N/A).`);
                return null;
              }
              if (!/^https:\/\//i.test(u)) {
                core.setFailed(`Invalid value for required field: ${label}. URL must start with https://.`);
                return null;
              }
              return u;
            }

            // Primary (current) issue form fields
            // DNS + domain registration/transfer are handled in a separate ticket.
            // Keep dnsControlled for backward compatibility with older website request issues.
            let dnsControlled = false;

            let websiteSituation = '';
            let currentWebsiteUrl = '';
            let technicalPocGitHubUsername = '';
            let domain = '';
            let charityName = '';
            let footerEmail = '';
            let footerPhone = '';
            let footerAddress = '';
            let footerEin = '';
            let footerSocialLinks = [];
            let leadershipLines = [];

            const isDisallowedValue = (value) => {
              if (value === undefined || value === null) return true;
              const trimmed = String(value).trim();
              if (!trimmed) return true;
              return /^n\/?a$/i.test(trimmed);
            };

            const isNA = (value) => /^n\/?a$/i.test(String(value || '').trim());

            const failIfNAProvided = (label, value) => {
              if (isNA(value)) {
                core.setFailed(`Invalid value: ${label} cannot be N/A.`);
                return true;
              }
              return false;
            };

            const hasUsZip = (value) => /\b\d{5}(?:-\d{4})?\b/.test(String(value || ''));

            const isHttpsUrl = (value) => /^https:\/\//i.test(String(value || '').trim());

            const phoneDigits = (value) => String(value || '').replace(/\D/g, '');
            const isValidUsPhone = (value) => {
              const d = phoneDigits(value);
              if (d.length === 10) return true;
              if (d.length === 11 && d.startsWith('1')) return true;
              return false;
            };

            if (isManual) {
              websiteSituation = normalizeInput(manualInputs.website_situation);
              currentWebsiteUrl = normalizeInput(manualInputs.current_website_url);
              technicalPocGitHubUsername = normalizeInput(manualInputs.technical_poc_github_username).replace(/^@/, '');

              domain = normalizeDomain(manualInputs.domain);
              charityName = normalizeInput(manualInputs.charity_name);
              footerEmail = normalizeInput(manualInputs.footer_email);
              footerPhone = normalizeInput(manualInputs.footer_phone);
              footerAddress = normalizeInput(manualInputs.footer_address);
              footerEin = normalizeInput(manualInputs.footer_ein);

              footerSocialLinks = parseMultiline(manualInputs.social_links);
              leadershipLines = parseMultiline(manualInputs.leadership_lines);
            } else {
              websiteSituation = normalizeInput(extractSection('Website Situation'));
              currentWebsiteUrl = normalizeInput(extractSection('Current Website URL (if any)'));
              technicalPocGitHubUsername = normalizeInput(extractSection('Technical POC GitHub Username'));
              technicalPocGitHubUsername = technicalPocGitHubUsername.replace(/^@/, '');

              domain = normalizeDomain(extractSection('Website Domain (no http://)'));
              charityName = normalizeInput(extractSection('Organization Name (as displayed)'));
              footerEmail = normalizeInput(extractSection('Footer Contact Email'));
              footerPhone = normalizeInput(extractSection('Footer Contact Phone'));

              const addressLine1 = normalizeInput(extractSection('Footer Mailing Address Line 1'));
              const addressCity = normalizeInput(extractSection('Footer Mailing City'));
              const addressState = normalizeInput(extractSection('Footer Mailing State/Province'));
              const addressPostal = normalizeInput(extractSection('Footer Mailing Postal Code'));

              footerAddress = buildAddress({
                line1: addressLine1,
                line2: '',
                city: addressCity,
                state: addressState,
                postal: addressPostal,
                country: 'United States',
              });

              footerEin = normalizeInput(extractSection('EIN / Tax ID'));

              const facebookUrl = validateRequiredUrl('Facebook URL', extractSection('Facebook URL'));
              if (facebookUrl === null) return;
              const xUrl = validateRequiredUrl('X / Twitter URL', extractSection('X / Twitter URL'));
              if (xUrl === null) return;
              const linkedinUrl = validateRequiredUrl('LinkedIn URL', extractSection('LinkedIn URL'));
              if (linkedinUrl === null) return;
              const githubUrl = validateRequiredUrl('GitHub URL', extractSection('GitHub URL'));
              if (githubUrl === null) return;

              footerSocialLinks = [
                `facebook: ${facebookUrl}`,
                `x: ${xUrl}`,
                `linkedin: ${linkedinUrl}`,
                `github: ${githubUrl}`,
              ];

              // Leadership can be provided either as a single multiline block (preferred)
              // or as individual leader fields (legacy primary form).
              const leadershipBlock = normalizeInput(extractSection('Board / Leadership'));
              if (leadershipBlock && !/^n\/?a$/i.test(leadershipBlock.trim())) {
                leadershipLines = leadershipBlock
                  .split(/\r?\n/)
                  .map(s => s.trim())
                  .filter(s => s && !/^n\/?a$/i.test(s));
              } else {
                leadershipLines = [];
                for (let i = 1; i <= 6; i++) {
                  const name = normalizeInput(extractSection(`Leader ${i} Name`));
                  const title = normalizeInput(extractSection(`Leader ${i} Role/Title`));
                  const linkedin = normalizeInput(extractSection(`Leader ${i} LinkedIn URL`));

                  if (!name) continue;
                  if (!title) leadershipLines.push(`${name} | Board Member | ${linkedin}`);
                  else leadershipLines.push(`${name} | ${title} | ${linkedin}`);
                }
              }
            }

            const usingPrimaryForm = !!domain;

            // Backward-compat: previous website request form fields
            // If the new headings are not present, fall back to the older headings.
            if (!domain) {
              dnsControlled = true;
              domain = normalizeDomain(extractSection('Apex Domain'));
              charityName = normalizeInput(extractSection('Charity / Organization Name'));
              footerEmail = normalizeInput(extractSection('Public Contact Email'));
              footerPhone = normalizeInput(extractSection('Public Contact Phone (optional)'));
              footerAddress = normalizeInput(extractSection('Public Mailing Address (optional)'));
              footerEin = normalizeInput(extractSection('EIN / Tax ID (optional)'));

              const footerSocialLegacy = normalizeInput(extractSection('Social Links (optional)'));
              if (footerSocialLegacy) {
                footerSocialLinks = footerSocialLegacy
                  .split(/\r?\n/)
                  .map(s => s.trim())
                  .filter(Boolean);
              }

              const leadershipLegacy = normalizeInput(extractSection('Board / Leadership'));
              if (leadershipLegacy) {
                leadershipLines = leadershipLegacy
                  .split(/\r?\n/)
                  .map(s => s.trim())
                  .filter(Boolean);
              }
            }

            if (!domain) {
              core.setFailed('Missing required field: domain.');
              return;
            }

            // Enforce non-placeholder values for required fields.
            // We cannot prevent users from typing `N/A` into a required field in GitHub Issue Forms,
            // so we block the workflow if it happens.
            if (!isManual) {
              const requiredChecks = [
                ['domain', domain],
                ['Organization Name (as displayed)', charityName],
                ['Footer Contact Email', footerEmail],
                ['Footer Contact Phone', footerPhone],
                ['EIN / Tax ID', footerEin],
                ['Technical POC GitHub Username', technicalPocGitHubUsername],
              ];

              for (const [label, value] of requiredChecks) {
                if (isDisallowedValue(value)) {
                  core.setFailed(`Invalid value for required field: ${label}. Please provide a real value (not N/A).`);
                  return;
                }
              }
            } else {
              // Manual dispatch: best-effort mode.
              // Domain is required; everything else is optional (but N/A is never allowed).
              if (isDisallowedValue(domain)) {
                core.setFailed('Invalid value for required field: domain. Please provide a real value (not N/A).');
                return;
              }
            }

            // Optional fields: blank is allowed, but N/A is not.
            if (failIfNAProvided('Current Website URL (if any)', currentWebsiteUrl)) return;
            if (failIfNAProvided('Organization Name (as displayed)', charityName)) return;
            if (failIfNAProvided('Footer Contact Email', footerEmail)) return;
            if (failIfNAProvided('Footer Contact Phone', footerPhone)) return;
            if (failIfNAProvided('EIN / Tax ID', footerEin)) return;
            if (failIfNAProvided('Technical POC GitHub Username', technicalPocGitHubUsername)) return;

            // Footer phone: must be a valid US phone number (10 digits, or 11 digits starting with 1).
            // Required for issue-based runs; manual runs validate only if provided.
            if (!isManual || !isDisallowedValue(footerPhone)) {
              if (!isValidUsPhone(footerPhone)) {
                core.setFailed('Footer Contact Phone must be a valid US phone number (10 digits, or 11 digits starting with 1).');
                return;
              }
            }

            // Optional current website URL: must be https:// if provided.
            if (currentWebsiteUrl && !isHttpsUrl(currentWebsiteUrl)) {
              core.setFailed('Current Website URL (if any) must start with https://.');
              return;
            }

            // Address requirement: must map to a real location (issue form).
            // Require Street/PO Box + City/State/ZIP and a valid US ZIP format.
            if (!isManual) {
              const line1 = normalizeInput(extractSection('Footer Mailing Address Line 1'));
              const city = normalizeInput(extractSection('Footer Mailing City'));
              const state = normalizeInput(extractSection('Footer Mailing State/Province'));
              const postal = normalizeInput(extractSection('Footer Mailing Postal Code'));

              for (const [label, value] of [
                ['Footer Mailing Address Line 1', line1],
                ['Footer Mailing City', city],
                ['Footer Mailing State/Province', state],
                ['Footer Mailing Postal Code', postal],
              ]) {
                if (isDisallowedValue(value)) {
                  core.setFailed(`Invalid value for required address field: ${label}. Please provide a real value (not N/A).`);
                  return;
                }
              }

              if (!hasUsZip(postal)) {
                core.setFailed('Footer Mailing Postal Code must be a valid US ZIP code (e.g., 85001 or 85001-1234).');
                return;
              }
            } else {
              // Manual dispatch uses a freeform address input.
              // If provided, require it to at least include a US ZIP.
              if (!isDisallowedValue(footerAddress)) {
                if (!hasUsZip(footerAddress)) {
                  core.setFailed('Footer address must include a valid US ZIP code (e.g., 85001 or 85001-1234).');
                  return;
                }
              }
            }

            // Leadership is displayed on the site. Require at least one leader line for issue-based runs.
            if (!isManual) {
              if (!leadershipLines || leadershipLines.length === 0) {
                core.setFailed('Board / Leadership is required. Provide at least one leader line.');
                return;
              }

              // Required leadership roles for primary website requests.
              // We require President, Secretary, and Treasurer (others optional).
              const requiredRolePatterns = [
                { role: 'President', re: /\bpresident\b/i },
                { role: 'Secretary', re: /\bsecretary\b/i },
                { role: 'Treasurer', re: /\btreasurer\b/i },
              ];

              const rolesFound = new Set();
              for (const line of leadershipLines || []) {
                const cleaned = String(line || '').trim().replace(/^[\*-]\s+/, '');
                if (!cleaned) continue;
                if (!cleaned.includes('|')) continue;
                const parts = cleaned.split('|').map(p => String(p || '').trim());
                if (parts.length < 2) continue;
                const role = parts[1] || '';
                for (const { role: requiredRole, re } of requiredRolePatterns) {
                  if (re.test(role)) rolesFound.add(requiredRole);
                }
              }

              const missingRoles = requiredRolePatterns
                .map(r => r.role)
                .filter(r => !rolesFound.has(r));
              if (missingRoles.length > 0) {
                core.setFailed(
                  `Board / Leadership must include these roles: President, Secretary, Treasurer. Missing: ${missingRoles.join(', ')}.`,
                );
                return;
              }
            }

            // Disallow N/A anywhere in leadership content (manual or issue).
            if (leadershipLines && leadershipLines.some(line => /\bn\/?a\b/i.test(line))) {
              core.setFailed('Board / Leadership cannot include N/A. Use real values; leave fields empty only where the format supports it (e.g., blank LinkedIn URL).');
              return;
            }

            // Leadership LinkedIn URLs: if provided, must be https://
            if (leadershipLines && leadershipLines.length > 0) {
              for (const line of leadershipLines) {
                const cleaned = String(line || '').trim().replace(/^[\*-]\s+/, '');
                if (!cleaned) continue;

                // Only validate pipe-delimited formats where a LinkedIn URL field is present.
                if (!cleaned.includes('|')) continue;
                const parts = cleaned.split('|').map(p => String(p || '').trim());
                if (parts.length < 3) continue;

                const linkedinUrl = parts[parts.length - 1];
                if (!linkedinUrl) continue;
                if (!isHttpsUrl(linkedinUrl)) {
                  core.setFailed('Leadership LinkedIn URLs must start with https:// (leave blank if not available).');
                  return;
                }
              }
            }

            // Social URLs: issue-based runs require all 4; manual runs are best-effort.
            if (isManual) {
              for (const line of footerSocialLinks || []) {
                if (/\bn\/?a\b/i.test(line)) {
                  core.setFailed('Social links cannot include N/A. Provide a real URL or leave it blank.');
                  return;
                }

                const clean = String(line || '').trim().replace(/^[\*-]\s+/, '');
                const m = clean.match(/^(?<k>[A-Za-z ]+)\s*:\s*(?<v>\S+)$/);
                if (!m) continue;
                const v = String(m.groups?.v || '').trim();
                if (v && !/^https:\/\//i.test(v)) {
                  core.setFailed('Social links must use https:// URLs.');
                  return;
                }
              }
            }

            const repoName = `FFC-EX-${domain}`;
            const org = process.env.WEBSITE_TARGET_ORG || 'FreeForCharity';
            const repoFull = `${org}/${repoName}`;

            const templateRepo = process.env.WEBSITE_TEMPLATE_REPO || 'FreeForCharity/FFC_Single_Page_Template';
            const runUrl = `${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;

            core.setOutput('skip', 'false');
            core.setOutput('issue_number', isManual ? '' : String(issue.number));
            core.setOutput('post_comments', isManual ? 'false' : 'true');
            core.setOutput('dns_controlled', dnsControlled ? 'true' : 'false');
            core.setOutput('website_situation', websiteSituation);
            core.setOutput('current_website_url', currentWebsiteUrl);
            core.setOutput('requester_github_username', requesterGitHubUsername);
            core.setOutput('technical_poc_github_username', technicalPocGitHubUsername);
            core.setOutput('domain', domain);
            core.setOutput('charity_name', charityName);
            core.setOutput('footer_email', footerEmail);
            core.setOutput('footer_phone', footerPhone);
            core.setOutput('footer_address_json', JSON.stringify(footerAddress));
            core.setOutput('footer_ein', footerEin);
            core.setOutput('footer_social_json', JSON.stringify(footerSocialLinks));
            core.setOutput('leadership_json', JSON.stringify(leadershipLines));
            core.setOutput('repo_name', repoName);
            core.setOutput('repo_full', repoFull);
            core.setOutput('template_repo', templateRepo);
            core.setOutput('run_url', runUrl);

  zone_check:
    runs-on: windows-latest
    environment: cloudflare-prod
    needs: [resolve]
    if: needs.resolve.outputs.skip != 'true'
    outputs:
      zone_controlled: ${{ steps.check.outputs.zone_controlled }}
      zone_account: ${{ steps.check.outputs.zone_account }}
      zone_exists_ffc: ${{ steps.check.outputs.zone_exists_ffc }}
      zone_exists_cm: ${{ steps.check.outputs.zone_exists_cm }}
    steps:
      - uses: actions/checkout@v4

      - name: Cloudflare source-of-truth zone check
        id: check
        shell: pwsh
        env:
          CLOUDFLARE_API_TOKEN_FFC: ${{ secrets.FFC_CLOUDFLARE_API_TOKEN_ZONE_AND_DNS }}
          CLOUDFLARE_API_TOKEN_CM: ${{ secrets.CM_CLOUDFLARE_API_TOKEN_ZONE_AND_DNS }}
        run: |
          $ErrorActionPreference = 'Stop'
          $domain = "${{ needs.resolve.outputs.domain }}"

          # Best-effort: if secrets are missing, treat as not controlled and continue.
          if ([string]::IsNullOrWhiteSpace($env:CLOUDFLARE_API_TOKEN_FFC) -or [string]::IsNullOrWhiteSpace($env:CLOUDFLARE_API_TOKEN_CM)) {
            Write-Host 'Cloudflare tokens missing; skipping zone check and treating domain as not controlled.' -ForegroundColor Yellow
            "zone_exists_ffc=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
            "zone_exists_cm=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
            "zone_controlled=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
            "zone_account=" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
            exit 0
          }

          $ffc = (& pwsh -NoProfile -File .\scripts\cloudflare-zone-get.ps1 -Domain $domain -Account FFC) | ConvertFrom-Json
          $cm  = (& pwsh -NoProfile -File .\scripts\cloudflare-zone-get.ps1 -Domain $domain -Account CM)  | ConvertFrom-Json

          $existsFfc = [bool]$ffc.exists
          $existsCm  = [bool]$cm.exists
          $controlled = ($existsFfc -or $existsCm)

          $account = ''
          if ($existsFfc) { $account = 'FFC' }
          elseif ($existsCm) { $account = 'CM' }

          $toFlag = {
            param([string]$Name, [bool]$Value)
            $v = if ($Value) { 'true' } else { 'false' }
            "$Name=$v" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
          }

          & $toFlag -Name 'zone_exists_ffc' -Value $existsFfc
          & $toFlag -Name 'zone_exists_cm' -Value $existsCm
          & $toFlag -Name 'zone_controlled' -Value $controlled

          "zone_account=$account" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

  announce:
    runs-on: ubuntu-latest
    needs: [resolve, zone_check]
    if: needs.resolve.outputs.skip != 'true' && needs.resolve.outputs.post_comments == 'true'
    steps:
      - name: Comment start
        uses: actions/github-script@v8
        with:
          script: |
            const issueNumber = Number('${{ needs.resolve.outputs.issue_number }}');
            const domain = '${{ needs.resolve.outputs.domain }}';
            const repoFull = '${{ needs.resolve.outputs.repo_full }}';
            const templateRepo = '${{ needs.resolve.outputs.template_repo }}';
            const runUrl = '${{ needs.resolve.outputs.run_url }}';
            const zoneControlled = '${{ needs.zone_check.outputs.zone_controlled }}' === 'true';
            const zoneAccount = '${{ needs.zone_check.outputs.zone_account }}';
            const websiteSituation = '${{ needs.resolve.outputs.website_situation }}';
            const requester = '${{ needs.resolve.outputs.requester_github_username }}';
            const technicalPoc = '${{ needs.resolve.outputs.technical_poc_github_username }}';

            const steps = zoneControlled
              ? [
                  '1) Configure DNS for GitHub Pages (Cloudflare)',
                  '2) Create repo from template + enable Pages + set custom domain',
                  '3) Apply footer + leadership content',
                ]
              : [
                  '1) Create repo from template + enable Pages (no custom domain)',
                  '2) Apply footer + leadership content',
                ];

            const body = [
              `Provisioning started for **${domain}**`,
              '',
              `- Target repo: **${repoFull}**`,
              `- Template: **${templateRepo}**`,
              `- Run: ${runUrl}`,
              websiteSituation ? `- Website situation: **${websiteSituation}**` : null,
              requester ? `- Requester: @${requester}` : null,
              technicalPoc ? `- Technical POC: @${technicalPoc}` : null,
              `- Cloudflare source-of-truth: **${zoneControlled ? 'Controlled (will set custom domain)' : 'Not controlled (no custom domain)'}**${zoneAccount ? ` (account: ${zoneAccount})` : ''}`,
              '',
              'Steps:',
              ...steps,
            ].filter(Boolean).join('\n');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body,
            });

  dns:
    runs-on: windows-latest
    environment: cloudflare-prod
    needs: [resolve, zone_check]
    if: needs.resolve.outputs.skip != 'true' && needs.zone_check.outputs.zone_controlled == 'true'
    steps:
      - uses: actions/checkout@v4

      - name: Validate required Cloudflare secrets
        shell: bash
        run: |
          if [ -z "${{ secrets.FFC_CLOUDFLARE_API_TOKEN_ZONE_AND_DNS }}" ]; then
            echo "::error::FFC_CLOUDFLARE_API_TOKEN_ZONE_AND_DNS secret is not set (environment: cloudflare-prod)";
            exit 1;
          fi
          if [ -z "${{ secrets.CM_CLOUDFLARE_API_TOKEN_ZONE_AND_DNS }}" ]; then
            echo "::error::CM_CLOUDFLARE_API_TOKEN_ZONE_AND_DNS secret is not set (environment: cloudflare-prod)";
            exit 1;
          fi

      - name: Enforce GitHub Pages DNS (apex + www)
        id: enforce
        shell: pwsh
        env:
          CLOUDFLARE_API_TOKEN_FFC: ${{ secrets.FFC_CLOUDFLARE_API_TOKEN_ZONE_AND_DNS }}
          CLOUDFLARE_API_TOKEN_CM: ${{ secrets.CM_CLOUDFLARE_API_TOKEN_ZONE_AND_DNS }}
        run: |
          $ErrorActionPreference = 'Stop'
          $domain = "${{ needs.resolve.outputs.domain }}"

          $outDir = Join-Path $env:RUNNER_TEMP 'website-provision-dns'
          New-Item -ItemType Directory -Force -Path $outDir | Out-Null

          $out = & pwsh -NoProfile -File .\Update-CloudflareDns.ps1 -Zone $domain -EnforceStandard -GitHubPagesOnly *>&1
          $outPath = Join-Path $outDir 'dns-enforce.txt'
          $out | Out-File -FilePath $outPath -Encoding utf8

          $audit = & pwsh -NoProfile -File .\Update-CloudflareDns.ps1 -Zone $domain -Audit -ErrorAction Continue *>&1
          $auditPath = Join-Path $outDir 'dns-audit-after.txt'
          $audit | Out-File -FilePath $auditPath -Encoding utf8

          "out_dir=$outDir" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: Upload DNS outputs
        uses: actions/upload-artifact@v6
        with:
          name: website-provision-dns
          path: ${{ steps.enforce.outputs.out_dir }}/*.txt
          if-no-files-found: error

  repo:
    runs-on: windows-latest
    environment: github-prod
    needs: [resolve, zone_check, dns]
    if: >-
      always() && needs.resolve.outputs.skip != 'true' && (needs.dns.result == 'success' ||
      needs.dns.result == 'skipped')
    steps:
      - uses: actions/checkout@v4

      - name: Validate required GitHub token
        shell: pwsh
        run: |
          if ([string]::IsNullOrWhiteSpace("${{ secrets.CBM_TOKEN }}")) {
            throw 'CBM_TOKEN secret is not set (environment: github-prod).'
          }

      - name: Create repo from template + enable Pages
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.CBM_TOKEN }}
        run: |
          $ErrorActionPreference = 'Stop'
          $repoFull = "${{ needs.resolve.outputs.repo_full }}"
          $repoName = "${{ needs.resolve.outputs.repo_name }}"
          $domain = "${{ needs.resolve.outputs.domain }}"
          $charityName = "${{ needs.resolve.outputs.charity_name }}"
          $templateRepo = "${{ needs.resolve.outputs.template_repo }}"
          $zoneControlled = "${{ needs.zone_check.outputs.zone_controlled }}" -eq 'true'

          if ([string]::IsNullOrWhiteSpace($charityName)) {
            $charityName = $domain
          }

          # Best-effort check: if repo already exists, skip creation.
          $exists = $false
          try {
            gh repo view $repoFull --json nameWithOwner 1>$null
            $exists = $true
          } catch {
            $exists = $false
          }

          if ($exists) {
            Write-Host "Repo already exists: $repoFull. Skipping creation." -ForegroundColor Yellow
          } else {
            $createParams = @{
              RepoName      = $repoName
              Organization  = "${{ env.WEBSITE_TARGET_ORG }}"
              Description   = "Website for $charityName ($domain)"
              TemplateRepo  = $templateRepo
              Visibility    = 'public'
              EnableIssues  = $true
              EnablePages   = $true
            }

            if ($zoneControlled) {
              $createParams.CNAME = $domain
            } else {
              $createParams.PagesDomainType = 'github-default'
            }

            ./scripts/Create-GitHubRepo.ps1 @createParams
          }

      - name: Add maintainers (requester + technical POC)
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.CBM_TOKEN }}
        run: |
          $ErrorActionPreference = 'Stop'

          $repoFull = "${{ needs.resolve.outputs.repo_full }}"
          $requester = "${{ needs.resolve.outputs.requester_github_username }}".Trim()
          $technicalPoc = "${{ needs.resolve.outputs.technical_poc_github_username }}".Trim().TrimStart('@')

          $users = @($requester, $technicalPoc)
          $users = $users | Where-Object { -not [string]::IsNullOrWhiteSpace($_) } | Select-Object -Unique

          foreach ($u in $users) {
            Write-Host "Adding maintainer: $u" -ForegroundColor Cyan
            gh api -X PUT "repos/$repoFull/collaborators/$u" -f permission=maintain 1>$null
          }

  content:
    runs-on: windows-latest
    environment: github-prod
    needs: [resolve, zone_check, repo]
    if: needs.resolve.outputs.skip != 'true'
    steps:
      - uses: actions/checkout@v4

      - name: Validate required GitHub token
        shell: pwsh
        run: |
          if ([string]::IsNullOrWhiteSpace("${{ secrets.CBM_TOKEN }}")) {
            throw 'CBM_TOKEN secret is not set (environment: github-prod).'
          }

      - name: Apply footer + leadership content
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.CBM_TOKEN }}
        run: |
          $ErrorActionPreference = 'Stop'

          $repoFull = "${{ needs.resolve.outputs.repo_full }}"
          $domain = "${{ needs.resolve.outputs.domain }}"
          $charityName = "${{ needs.resolve.outputs.charity_name }}"
          $websiteSituation = "${{ needs.resolve.outputs.website_situation }}"
          $currentWebsiteUrl = "${{ needs.resolve.outputs.current_website_url }}"
          $requester = "${{ needs.resolve.outputs.requester_github_username }}"
          $technicalPoc = "${{ needs.resolve.outputs.technical_poc_github_username }}"
          $zoneControlled = "${{ needs.zone_check.outputs.zone_controlled }}" -eq 'true'

          $footerEmail = "${{ needs.resolve.outputs.footer_email }}"
          $footerPhone = "${{ needs.resolve.outputs.footer_phone }}"
          $footerAddress = '${{ needs.resolve.outputs.footer_address_json }}' | ConvertFrom-Json
          $footerEin = "${{ needs.resolve.outputs.footer_ein }}"

          $footerSocial = '${{ needs.resolve.outputs.footer_social_json }}' | ConvertFrom-Json
          $leadership = '${{ needs.resolve.outputs.leadership_json }}' | ConvertFrom-Json

          $workDir = Join-Path $env:RUNNER_TEMP 'website-provision-repo'
          if (Test-Path $workDir) { Remove-Item -Recurse -Force $workDir }
          New-Item -ItemType Directory -Force -Path $workDir | Out-Null

          $cloneDir = Join-Path $workDir 'repo'
          gh repo clone $repoFull $cloneDir
          Set-Location $cloneDir

          git config user.name "github-actions"
          git config user.email "github-actions@users.noreply.github.com"

          $content = [ordered]@{
            domain = $domain
            charityName = $charityName
            websiteSituation = $websiteSituation
            currentWebsiteUrl = $currentWebsiteUrl
            requesterGitHubUsername = $requester
            technicalPocGitHubUsername = $technicalPoc
            cloudflareZoneControlled = $zoneControlled
            footer = [ordered]@{
              email = $footerEmail
              phone = $footerPhone
              address = $footerAddress
              ein = $footerEin
              socialLinks = @($footerSocial)
            }
            leadership = @($leadership)
            generatedUtc = (Get-Date).ToUniversalTime().ToString('o')
          }

          $json = $content | ConvertTo-Json -Depth 8
          $json | Out-File -FilePath 'ffc-content.json' -Encoding utf8

          # Patch the actual React template files in the newly provisioned repo.
          function Test-SocialLinksPresent {
            param([string[]]$Links)
            if (-not $Links -or $Links.Count -eq 0) { return $false }
            $map = @{}
            foreach ($line in $Links) {
              if ([string]::IsNullOrWhiteSpace($line)) { continue }
              $m = [regex]::Match($line.Trim(), '^(?<k>[A-Za-z ]+)\s*:\s*(?<v>https://\S+)$')
              if (-not $m.Success) { continue }
              $k = $m.Groups['k'].Value.Trim().ToLowerInvariant()
              $map[$k] = $m.Groups['v'].Value.Trim()
            }
            foreach ($k in @('facebook', 'x', 'linkedin', 'github')) {
              if (-not $map.ContainsKey($k)) { return $false }
            }
            return $true
          }

          $canApplyTemplate = (
            -not [string]::IsNullOrWhiteSpace($charityName) -and
            -not [string]::IsNullOrWhiteSpace($footerEmail) -and
            -not [string]::IsNullOrWhiteSpace($footerPhone) -and
            -not [string]::IsNullOrWhiteSpace($footerEin) -and
            -not [string]::IsNullOrWhiteSpace($footerAddress) -and
            ($leadership.Count -gt 0) -and
            (Test-SocialLinksPresent -Links @($footerSocial))
          )
          if ($canApplyTemplate) {
            $scriptPath = Join-Path $env:GITHUB_WORKSPACE 'scripts/Apply-WebsiteReactTemplate.ps1'
            if (-not (Test-Path $scriptPath)) {
              throw "Customization script not found: $scriptPath"
            }

            & $scriptPath `
              -RepoPath $cloneDir `
              -Domain $domain `
              -CharityName $charityName `
              -FooterEmail $footerEmail `
              -FooterPhone $footerPhone `
              -FooterAddress $footerAddress `
              -FooterEin $footerEin `
              -FooterSocial @($footerSocial) `
              -LeadershipLines @($leadership)
          } else {
            Write-Host 'Skipping React template patch: missing required footer/leadership inputs.' -ForegroundColor Yellow
          }

          git add -A
          git diff --cached --quiet
          if ($LASTEXITCODE -ne 0) {
            git commit -m "chore: apply footer + leadership content" | Out-Null
            git push origin HEAD:main
          } else {
            Write-Host "No content changes detected; skipping commit." -ForegroundColor Yellow
          }

  finalize:
    runs-on: ubuntu-latest
    needs: [resolve, zone_check, dns, repo, content]
    if: >-
      always() && needs.resolve.outputs.skip != 'true' && needs.resolve.outputs.post_comments ==
      'true' && (needs.dns.result == 'success' || needs.dns.result == 'skipped') &&
      needs.repo.result == 'success' && needs.content.result == 'success'
    steps:
      - name: Comment completion
        uses: actions/github-script@v8
        with:
          script: |
            const issueNumber = Number('${{ needs.resolve.outputs.issue_number }}');
            const domain = '${{ needs.resolve.outputs.domain }}';
            const repoFull = '${{ needs.resolve.outputs.repo_full }}';
            const repoUrl = `${context.serverUrl}/${repoFull}`;
            const runUrl = '${{ needs.resolve.outputs.run_url }}';
            const zoneControlled = '${{ needs.zone_check.outputs.zone_controlled }}' === 'true';

            const marker = '<!-- website-provision:completed -->';
            const dnsNote = zoneControlled
              ? '- DNS enforcement used the standard GitHub Pages-only enforcement (apex + www).'
              : '- DNS was NOT changed and GitHub Pages custom domain was NOT set (domain is not in FFC-controlled Cloudflare yet).';
            const dnsManual = zoneControlled
              ? []
              : [
                  '',
                  'Next steps:',
                  '- Create a follow-up ticket to add/transfer the domain into FFC Cloudflare, then point DNS to GitHub Pages and set the Pages custom domain.',
                  '- GitHub custom domain docs (for reference):',
                  '  https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site',
                ];
            const body = [
              marker,
              `Provisioning completed for **${domain}**`,
              '',
              `- Repo: ${repoUrl}`,
              `- Run: ${runUrl}`,
              '',
              'Notes:',
              dnsNote,
              '- Content was applied directly to the React template footer + leadership sections (and recorded in `ffc-content.json`).',
              ...dnsManual,
            ].join('\n');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body,
            });
